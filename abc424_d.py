###############################################
問題文
H行W列のマス目があり、各マスは白または黒に塗られています。
マス目の上からi番目(1≤i≤H)かつ左からj番目(1≤j≤W)のマスをマス(i,j)と表すことにします。
マス目の状態はH個の、.と#のみからなる長さWの文字列S1​,S2​,…,SH​によって与えられ、
Si​のj文字目が.のとき、マス(i,j)が白く塗られていることを、#のときマス(i,j)が黒く塗られていることを表します。
高橋君はいくつか（0個でも良い）の黒く塗られたマスを白に塗り替えることで、マス目が黒く塗られたマスのみからなる2×2の部分を持たないようにしたいです。
より厳密には、次の条件をみたすようにしたいです。
1≤i≤H−1,1≤j≤W−1をみたす任意の整数の組(i,j)について、
マス(i,j),マス(i,j+1),マス(i+1,j),マス(i+1,j+1)のうち少なくとも1つは白く塗られている。
高橋君が目標を達成するために、白く塗り替える必要のあるマスの個数の最小値を求めてください。
T個のテストケースが与えられるので、それぞれについて答えを求めてください。
制約
1≤T≤100
2≤H≤7
2≤W≤7
Si​は.と#のみからなる長さWの文字列
T,H,Wは整数
###############################################
入力例 1
2   
5 5
####.
##.##
#####
.####
##.#.
2 2
..
..
  
出力例 1
3
0
###############################################
[titia AC] この解法を説明する、良いところを指摘する、改善点があれば指摘する

import sys
input = sys.stdin.readline

T=int(input())

for tests in range(T):
    H,W=map(int,input().split())

    MAP=[input().strip() for i in range(H)]

    DP=[0]*(1<<W)
    DP[0]=0

    for i in range(H):
        NDP=[1<<30]*(1<<W)

        x=0
        for j in range(W):
            if MAP[i][j]=="#":
                x^=(1<<j)

        for j in range(1<<W):
            plus=(x^j).bit_count()

            for k in range(1<<W):
                flag=1

                for l in range(W-1):
                    if j & (1<<l)!=0 and j & (1<<(l+1))!=0 and k & (1<<l)!=0 and k & (1<<(l+1))!=0:
                        flag=0
                        break

                if flag:
                    NDP[j]=min(NDP[j],DP[k]+plus)

        #print(DP)

        DP=NDP

    print(min(DP))

###############################################
[cgpt評]

---

## 解法の全体像

* 制約は $H,W \le 7$ と小さいので、**行ごとに状態をビットマスクで管理する DP** が可能です。
* 各行について「最終的に黒に残すマスのパターン」を全探索し、隣接する行と整合性があるかを確認しながら最小コストを更新していきます。

---

## コードの仕組み

### 1. 入力

```python
T=int(input())
for tests in range(T):
    H,W=map(int,input().split())
    MAP=[input().strip() for i in range(H)]
```

* $T$ テストケースを処理。
* `MAP` に盤面を格納。

---

### 2. DP 初期化

```python
DP=[0]*(1<<W)
DP[0]=0
```

* `DP[mask]` = 「直前の行の最終的な黒マス配置が `mask` のときの最小塗り替えコスト」。
* 1行目の前には何もないので `DP[0]=0` で開始。

---

### 3. 各行の処理

```python
for i in range(H):
    NDP=[1<<30]*(1<<W)
```

* `NDP` が次の行の DP テーブル。

---

### 4. この行の元の黒マスをビットに

```python
x=0
for j in range(W):
    if MAP[i][j]=="#":
        x^=(1<<j)
```

* `x` = この行の「入力で黒のマス」。
* ビットマスクで黒マスを 1 にする。

---

### 5. この行をどの配置に直すか全探索

```python
for j in range(1<<W):
    plus=(x^j).bit_count()
```

* `j` = 「この行の最終的な黒配置」。
* `(x^j)` で変えたマスを数え、`plus` にコスト（塗り替え数）が入る。

---

### 6. 前の行との整合性確認

```python
for k in range(1<<W):
    flag=1
    for l in range(W-1):
        if j & (1<<l)!=0 and j & (1<<(l+1))!=0 and k & (1<<l)!=0 and k & (1<<(l+1))!=0:
            flag=0
            break
    if flag:
        NDP[j]=min(NDP[j],DP[k]+plus)
```

* `k` = 前の行の配置。
* 各 `l` について「2行連続で隣り合う黒マスが 2 個並んでいないか」をチェック。

  * 条件 `j&(1<<l) and j&(1<<(l+1)) and k&(1<<l) and k&(1<<(l+1))` は、
    「行 i に (l,l+1) が黒で、行 i-1 にも (l,l+1) が黒 → 2×2 黒ブロック成立」を意味する。
* これがあれば `flag=0` で不許可。
* OK なら `NDP[j] = min(NDP[j], DP[k]+plus)` で遷移。

---

### 7. DP 更新

```python
DP=NDP
```

* 行を進める。

---

### 8. 答え

```python
print(min(DP))
```

* 最後の行まで見たあと、最小値が答え。

---

## 良いところ

1. **状態設計がシンプル**
   行をビットマスクにして DP する典型的なテクニックで、問題の「2×2 制約」を自然に表現できている。

2. **計算量が十分小さい**

   * 行ごとに $2^W \times 2^W \times W$ の計算。
   * $W=7$ でも $128^2 \times 7 \approx 1.1 \times 10^5$ → 全く問題ない。

3. **正確に最小値を取れる**
   全パターンを試すので塗り替え数が最小になることが保証される。

---

## 改善点

1. **内側のループ効率化**

   * `for k in range(1<<W)` 内で毎回 `for l in range(W-1)` を回している。
   * 実は「2×2 黒ブロックがあるかどうか」は `mask` ごとに前処理しておける。
     例えば `bad[j][k] = True/False` を先に作っておけば、`O(1)` で判定できて高速化可能。
   * ただし制約が小さいので現状でも十分 AC。

2. **変数名を改善すると読みやすい**

   * `x` → `orig_mask`
   * `j` → `cur_mask`
   * `k` → `prev_mask`
     などにすると理解しやすくなる。

3. **初期 DP の扱い**

   * `DP=[0]*(1<<W)` としているが、実際には最初の行はどんな `j` も選べるので、1行目用に `NDP` を作ってから開始しても良い。

---

## まとめ

この titia さんの解法は

* **行ごとの黒配置をビットマスクで管理する DP**
* **前行とのみ整合性をチェックすることで 2×2 黒ブロックを防止**
* **最小塗り替え数を累積**

という非常に教科書的で美しいアプローチです。
計算量も小さく、AtCoder/Codeforces 系の「盤面 + ビット DP」問題として模範的な解法です。

---

###############################################
[deepeek評]

このコードは、**動的計画法（DP）** を用いて効率的に問題を解いています。以下にその良い点と改善点を説明します。

## 良い点

### 1. **状態圧縮DPの巧みな適用**
- 各列の黒マスの状態をビットマスク（`1<<W`）で表現し、状態数を `2^W` に抑えています。
- W≤7 なので最大128状態で、計算量が現実的です。

### 2. **効率的な状態遷移**
- 現在行の状態 `j` と前の行の状態 `k` の組み合わせをチェックし、2×2の黒マスができないように制約を課しています。
- `for l in range(W-1):` の部分で、隣接する2列×2行の4マスが全て黒にならないかを確認しています。

### 3. **ビット演算の効果的な利用**
- `(x^j).bit_count()` で、元のマップとの差分（塗り替え必要数）を効率的に計算。
- ビット演算による状態チェックが高速です。

### 4. **メモリ効率**
- 2行分のDPテーブルだけ保持するローテーション方式で、メモリ使用量を抑えています。

## 改善点

### 1. **初期化の明確化**
```python
# 現在のコード
DP=[0]*(1<<W)
DP[0]=0

# 改善案：最初の行の処理を明確に
DP = [1<<30] * (1<<W)
DP[0] = 0  # 最初の行の前には何もないので、状態0のみ可能
```
最初の行の前は全て白い行があると考えると、状態0のみが有効です。

### 2. **境界条件の考慮不足**
現在のコードは **上方向のチェックのみ** で、最後の行について下方向のチェックが不足しています。
最終行では、次の行がないため2×2ブロックの下方向の制約が緩和されますが、コードは同じロジックで処理しています。

### 3. **可読性向上**
```python
# ビットマスクに名前を付ける
MASK_ALL_BLACK = (1 << l) | (1 << (l+1))

# 条件チェックを関数化
def has_2x2_black(current_row, prev_row, col):
    mask = (1 << col) | (1 << (col+1))
    return (current_row & mask == mask) and (prev_row & mask == mask)

# メインループ内で
for col in range(W-1):
    if has_2x2_black(j, k, col):
        flag = False
        break
```

### 4. **最終状態の扱い**
最終行では、次の行がないため状態に関わらずコスト0で終了可能です。
現在のコードは最小値を取るだけでこれに対応していますが、明示的に記述した方が良いでしょう。

## 改善版コードのイメージ

```python
import sys
input = sys.stdin.readline

T = int(input())

for tests in range(T):
    H, W = map(int, input().split())
    MAP = [input().strip() for _ in range(H)]
    
    # DP初期化：最初の行の前は状態0のみ可能
    DP = [1<<30] * (1<<W)
    DP[0] = 0
    
    for i in range(H):
        NDP = [1<<30] * (1<<W)
        
        # 現在行の元の黒マスパターン
        original = 0
        for j in range(W):
            if MAP[i][j] == "#":
                original |= (1 << j)
        
        # 全ての状態遷移を試す
        for prev_mask in range(1<<W):  # 前の行の状態
            if DP[prev_mask] == 1<<30:
                continue
                
            for curr_mask in range(1<<W):  # 現在行の状態
                # 2×2の黒ブロックチェック
                valid = True
                for col in range(W-1):
                    # 2列×2行が全て黒かチェック
                    col_mask = (1 << col) | (1 << (col+1))
                    if (curr_mask & col_mask == col_mask and 
                        prev_mask & col_mask == col_mask):
                        valid = False
                        break
                
                if valid:
                    # 塗り替えコスト計算
                    cost = (original ^ curr_mask).bit_count()
                    NDP[curr_mask] = min(NDP[curr_mask], DP[prev_mask] + cost)
        
        DP = NDP
    
    # 最終行は次の行がないので、どの状態でもOK
    print(min(DP))
```

## まとめ
この解法は**制約を活かした効率的なアプローチ**で、小さいH,Wに対して最適です。ビット演算を駆使した状態管理が巧妙で、競技プログラミングの典型的な良い解法と言えます。改善点は主にコードの明確化とエッジケースの考慮です。
###############################################
[gemini評]

提出されたコードは、与えられたグリッドの問題を解くための**動的計画法 (DP)** を用いた正しいアプローチです。この解法は、制約が小さい場合に非常に効果的です。以下に、その解法を説明し、良い点と改善点を指摘します。

### 解法の説明

このコードは、**行ごとに**グリッドを処理する**ビットDP**で問題を解決しています。DPの状態は、その行における**塗り替え後のマスの状態**をビット列で表現しています。

1.  **DPテーブルの定義**: `DP[j]` は、「前の行までの処理を終えた時点で、その行の状態（塗り替え後のマスが黒であるかどうかの情報）がビット列 `j` である場合の、塗り替えたマスの最小個数」を表します。

2.  **ループの構造**:
    * `for i in range(H)`: グリッドを上から順に1行ずつ見ていきます。
    * `NDP = [1<<30] * (1<<W)`: 新しい行の状態を計算するためのDPテーブルを初期化します。`1<<30` は十分に大きな値で、無限大を意味します。
    * `x`: `i` 行目の**元の**状態をビット列で表現します。マスが`#`であれば対応するビットを立てます。
    * `for j in range(1<<W)`: `i` 行目の**塗り替え後の**すべての可能な状態 `j` を試します。
    * `plus = (x^j).bit_count()`: `x` と `j` を比較し、塗り替えが必要なマスの数を計算します。具体的には、元の状態 `x` で黒（ビットが1）だったマスが、新しい状態 `j` で白（ビットが0）になっている箇所の数を数えます。`x^j` は、元の状態と新しい状態が異なるビットを特定し、`bit_count()` でその数を数えています。
    * `for k in range(1<<W)`: 前の行（`i-1`行目）のすべての可能な状態 `k` を試します。
    * **遷移条件**: `if flag:` の部分で、`i-1`行目の状態 `k` と `i` 行目の状態 `j` の組み合わせが、2x2の黒いマスのブロックを生成しないかを確認します。
        * `for l in range(W-1)`: `l` 列目と `l+1` 列目に着目します。
        * `if j & (1<<l)!=0 and ...`: `i` 行目の `l` 列と `l+1` 列が黒（ビットが1）であり、かつ `i-1` 行目の `l` 列と `l+1` 列も黒であるかを確認します。この4つのマスがすべて黒であれば `flag=0` となり、この遷移は無効となります。
    * `NDP[j]=min(NDP[j],DP[k]+plus)`: 条件を満たす場合に、`NDP[j]` を `DP[k] + plus` で更新します。
    * `DP = NDP`: 現在の行の計算が終わったら、`NDP` を `DP` にコピーし、次の行の計算に備えます。

3.  **最終的な答え**: すべての行を処理し終えた後、最後の行のDPテーブル `DP` の最小値が、塗り替えが必要なマスの最小個数となります。

---

### 良い点

* **正しいロジック**: `H, W ≤ 7` という制約を最大限に活かした、効率的かつ正しい**状態圧縮DP**の解法です。これは、この問題に対する標準的なアプローチの一つです。
* **計算量の最適化**: `(x^j).bit_count()` のように、Pythonの組み込み関数をうまく使っており、塗り替えコストの計算が簡潔に書かれています。
* **明確な状態管理**: 1行の`W`個のマスの状態を`1<<W`のビット列で表現しており、DPの状態遷移が非常に明確です。

---

### 改善点

* **変数名**: `j`, `k`, `l` といった変数名が使われていますが、それぞれが**現在の行の状態**、**前の行の状態**、**列インデックス**を意味することがコメントで補足されると、より可読性が高まります。
* **冗長なループ**: `for j in range(1<<W):` と `for k in range(1<<W):` の二重ループは、`O((2^W)^2)` の計算量になります。これは`W=7`の場合、`O(128^2) = O(16384)` となり、`H`倍しても十分に高速です。
    * **最適化案**: 遷移の計算を少し工夫することで、`O(H * (2^W)^2)` から `O(H * W * (2^W)^2)` へと削減できる可能性もありますが、現状のコードでも十分高速なので、大きな問題ではありません。
* **コメントの追加**: 解法の複雑さから、特にDPの定義や状態遷移のロジックについて、コメントを追加すると、他の人がコードを理解するのに役立ちます。例えば、`# DP[j] represents the min cost for state j` のようなコメントがあると良いでしょう。

全体として、このコードは非常にうまく設計されており、与えられた問題の制約下では、このアプローチが最も効率的でエレガントな解法の一つと言えます。

###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
[ai AC]
import sys

def solve():
    H, W = map(int, sys.stdin.readline().split())
    S = [sys.stdin.readline().strip() for _ in range(H)]

    dp = [[float('inf')] * (2**W) for _ in range(H + 1)]
    dp[0][0] = 0

    for i in range(H):
        for prev_mask in range(2**W):
            if dp[i][prev_mask] == float('inf'):
                continue

            for current_mask in range(2**W):
                changes = 0
                is_valid = True

                for j in range(W):
                    is_originally_black = (S[i][j] == '#')
                    is_current_black = (current_mask >> j) & 1
                    
                    if is_originally_black and not is_current_black:
                        changes += 1
                    
                    if not is_originally_black and is_current_black:
                        is_valid = False
                        break
                
                if not is_valid:
                    continue

                if i > 0:
                    for j in range(W - 1):
                        if ((prev_mask >> j) & 1) and ((prev_mask >> (j + 1)) & 1) and \
                           ((current_mask >> j) & 1) and ((current_mask >> (j + 1)) & 1):
                            is_valid = False
                            break
                
                if is_valid:
                    dp[i + 1][current_mask] = min(dp[i + 1][current_mask], dp[i][prev_mask] + changes)

    min_changes = min(dp[H])
    print(min_changes)

T = int(sys.stdin.readline())
for _ in range(T):
    solve()
###############################################
###############################################
###############################################
