###############################################
# atcoder.scc の使い方

`atcoder.scc` は強連結成分分解(Strongly Connected Components)を行うためのライブラリです。

## 基本的な使い方

```python
from atcoder.scc import SCCGraph

# グラフの初期化(頂点数を指定)
g = SCCGraph(n)

# 辺の追加
g.add_edge(u, v)  # u から v への有向辺を追加

# 強連結成分分解の実行
scc = g.scc()  # 強連結成分のリストを返す
```

## メソッド詳細

### `SCCGraph(n)`
- **引数**: `n` - 頂点数
- **機能**: n頂点0辺の有向グラフを作成

### `add_edge(u, v)`
- **引数**: `u`, `v` - 頂点番号 (0-indexed)
- **機能**: 頂点uから頂点vへの有向辺を追加
- **計算量**: O(1)

### `scc()`
- **戻り値**: `List[List[int]]` - 強連結成分のリスト
- **機能**: 強連結成分分解を実行
- **計算量**: O(V + E) (V: 頂点数, E: 辺数)
- **特徴**: トポロジカル順序で返される(後ろの成分から前の成分への辺は存在しない)

## 使用例

```python
from atcoder.scc import SCCGraph

# 6頂点のグラフを作成
g = SCCGraph(6)

# 辺を追加
g.add_edge(0, 1)
g.add_edge(1, 2)
g.add_edge(2, 0)  # 0-1-2 でサイクル
g.add_edge(2, 3)
g.add_edge(3, 4)
g.add_edge(4, 5)
g.add_edge(5, 3)  # 3-4-5 でサイクル

# 強連結成分分解
components = g.scc()

# 結果の表示
for i, component in enumerate(components):
    print(f"成分 {i}: {component}")

# 出力例:
# 成分 0: [3, 4, 5]
# 成分 1: [0, 1, 2]
```

## よくある応用

### 1. DAGの構築
強連結成分を1つの頂点にまとめることで、元のグラフをDAG(有向非巡回グラフ)に変換できます。

```python
components = g.scc()
# 各頂点がどの成分に属するかを記録
comp_id = [0] * n
for i, comp in enumerate(components):
    for v in comp:
        comp_id[v] = i
```

### 2. 2-SAT問題
論理式の充足可能性を判定する際に使用します。

## 注意点

- 頂点番号は **0-indexed** です
- `scc()` の結果はトポロジカル順序になっています
- 各成分内の頂点の順序は不定です
###############################################
###############################################
###############################################
[mean]
from atcoder.scc import SCCGraph


def solve(N, A):
    G = SCCGraph(N)
    for x, a in enumerate(A):
        G.add_edge(x, a)

    ans = 0
    for group in G.scc():
        if (s := len(group)) > 1:
            ans += s
        else:
            x = group[0]
            ans += int(x == A[x])

    return ans


def main():
    N = int(input())
    A = list(map(int, input().split()))
    A = [a - 1 for a in A]
    ans = solve(N, A)
    print(ans)


if __name__ == "__main__":
    main()

###############################################
###############################################
###############################################
###############################################
[sun]
N = int(input())
A = [0]+list(map(int, input().split()))
ret = 0
vis = [0] * (1+N)

def find(start):
  l = [start]
  while True:
    c = l[-1]
    nxt = A[c]
    if vis[nxt]:
      idx = len(l)
      for i in range(len(l)):
        if l[i]==nxt: 
          idx=i
          break
      return len(l)-idx
    vis[nxt] = 1
    l.append(nxt)

for i in range(1, N+1):
  if vis[i]: continue
  vis[i] = 1
  if A[i] == i:
    ret += 1
  else:
    ret += find(i)
print(ret)
###############################################
###############################################
###############################################
###############################################
###############################################
問題文長さNの数列A=(A1​,A2​,…,AN​)が与えられます。ここで、各Ai​(1≤i≤N)は1≤Ai​≤Nをみたします。
高橋君と青木君がN回ゲームを行います。i=1,2,…,N回目のゲームは次のようにして行われます。
青木君が正整数Ki​を指定する。青木君の指定したKi​を聞いた後、高橋君は1以上N以下の整数Si​を選び、黒板に書く。
その後、Ki​回次の操作を繰り返す。黒板にxが書かれているとき、それを消し、Ax​を新しく書く。
Ki​回の操作の後で黒板に書かれている整数がiならばi回目のゲームは高橋君の勝ち、そうでないならば青木君の勝ちとなります。
ここで、Ki​,Si​はi=1,2,…,Nに対して独立に選ぶ事ができます。
両者が、自身が勝つために最善の行動をとったとき、N回のゲームのうち高橋君が勝つ回数を求めてください。
制約1≤N≤2×1051≤Ai​≤N入力はすべて整数
###############################################
###############################################
###############################################
###############################################
###############################################
