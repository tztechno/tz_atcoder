##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

---

## 1. 初期化とグラフの設定

* **`N, M`**: `N` は都市（ノード）の数、`M` は初期の道路（辺）の数です。
* **`D`**: これはグラフの隣接行列を表す `(N+1) x (N+1)` の2D配列です。`D[i][j]` は都市 `i` と都市 `j` の間の最短距離を格納します。
* **`INF`**: 非常に大きな値（1を60ビット左シフトしたもの）で、直接パスがないことを示す無限大として使われます。
* **初期距離**:
    * `D[i][i] = 0` (すべての `i` について): 都市から自分自身への距離は0です。
    * コードは `M` 個の道路接続 (`a`, `b`, `c`) を読み込みます。
    * `a` と `b` は0-インデックスに調整されます。
    * `c` (コスト) は**2倍**されます。これは重要なポイントで、後で半分の距離を扱ったり、特定の制約に対処したりする可能性があります。たとえば、往復の合計距離を計算することに関連しているか、元の `c` が半整数であった場合に浮動小数点数を避ける方法かもしれません。
    * `D[a][b] = D[b][a] = min(D[a][b], c)`: これにより、`a` と `b` の間の直接距離（およびその逆）が、現在の値と新しい道路のコストの最小値に設定され、同じ2つの都市間に複数の道路がある場合も処理されます。

---

## 2. 空路の処理

* **`K, T`**: `K` は空路がある都市の数、`T` は空路のコストです。
* **`Air`**: 空路が利用可能な都市のリストです。
* **仮想ノード `N`**: コードは、グラフの `D` 行列の `N+1` 次元を使って仮想ノード `N` を導入します。この仮想ノードは「航空ハブ」を表します。
* **空路都市と仮想ノードの接続**: `Air` 内の各都市 `a` について、`D[a][N] = D[N][a] = T` が設定されます。これは、空路アクセス可能な都市とこの仮想航空ハブの間にコスト `T` の直接接続があることを意味します。これにより、空路アクセス可能な都市から別の空路アクセス可能な都市へ、航空ハブを経由して合計 `2 * T` のコスト（例: 都市Aからハブへ、次にハブから都市Bへ）で移動できるモデルが効果的に作られます。

---

## 3. ワーシャル・フロイド法

* **`for k in range(N + 1): ...`**: これはワーシャル・フロイド法の核となる部分です。すべてのノードペア間の最短パスを計算します。
* このアルゴリズムは、すべての中間ノード `k` を反復処理します。各ソース `i` とデスティネーション `j` のペアについて、`i` から `k` へ、次に `k` から `j` へ移動する方が現在の `D[i][j]` よりも短いパスを提供するかどうかをチェックします。
* このブロックの後、`D` 行列には、道路と空路（仮想ノード `N` を介して）の両方を考慮した、すべてのノードペア間の最短パス距離が含まれます。

---

## 4. 初期合計距離の計算

* **`ANS = sum(...)`**: これは、`i < j` および `i, j < N` のすべての最短パス距離 `D[i][j]` の合計を計算します。
    * この初期合計では、仮想ノード `N` を含むパスは特に除外されます。
    * `D[i][j] < INF` の条件により、到達可能なペアのみが含まれます。
    * `i < j` の条件により、`D[i][j]` と `D[j][i]` の二重カウントが回避され、`D[i][i]` も除外されます。

---

## 5. `update_dist` 関数

* この関数は、辺の重みが変更されたときに最短パスの合計を効率的に更新するために非常に重要です。
* **`update_dist(x, y, new_dist)`**: 2つのノード `x`, `y` と、それらの間の直接パスの `new_dist` を引数に取ります。
* グラフ内のすべての可能なペア `(i, j)` (ノード `N` を含む) を反復処理します。
* 各ペア `(i, j)` について、2つの潜在的な新しいパスを考慮します。
    1.  `D[i][x] + new_dist + D[y][j]`: `i` から `x` へ、次に `x` から `y` へ (`new_dist` で)、次に `y` から `j` へ。
    2.  `D[i][y] + new_dist + D[x][j]`: `i` から `y` へ、次に `y` から `x` へ (`new_dist` で)、次に `x` から `j` へ。
* **`d = min(d1, d2)`**: これら2つのパスの最小値が取られます。
* **`ANS` の更新**:
    * もし `d < D[i][j]` (より短いパスが見つかったことを意味する) かつ `i` と `j` の両方が実際の都市（`N` 未満）である場合、`ANS`（実際の都市間の距離の合計）が更新されます。
    * もし元の `D[i][j]` が `INF` (到達不可能) であった場合、新しい短い距離 `d` が `ANS` に追加されます。
    * そうでなければ（`D[i][j]` が到達可能であった場合）、距離が減少したため、`D[i][j] - d` の差が `ANS` から差し引かれます。
* **`D` 行列の更新**: `D[i][j] = D[j][i] = d`: `D` 行列自体が新しい最短距離で更新されます。これは、変更された辺に対してワーシャル・フロイドのロジックを部分的に再適用するのと同等です。

---

## 6. クエリの処理

* **`Q = int(input())`**: クエリの数。
* **`LANS = []`**: タイプ3のクエリの結果を格納するリスト。
* コードは3種類のクエリを処理します。
    * **タイプ3 (`t == 3`)**: 現在の最短パス合計 `ANS` を `LANS` に追加します。
    * **タイプ2 (`t == 2`)**:
        * 空路のある都市 `x` が指定されます。
        * `D[x][N] = D[N][x] = T`: `x` と仮想航空ハブ `N` の間の直接接続をコスト `T` で再確立します。これは、空路を再アクティブ化したり、そのコストが `T` であることを保証するために使用される可能性があります。
        * `update_dist(x, N, T)`: この変更によりすべての最短パスを再評価し、更新するために `update_dist` が呼び出されます。
    * **タイプ1 (`t == 1`)**:
        * ノード `x`, `y` と新しい道路コスト `z` が与えられます。
        * `z` は、初期の道路コストと同様に2倍されます。
        * `if D[x][y] > z`: もし新しい道路が `D[x][y]` に現在存在するよりも `x` と `y` の間に短い直接パスを提供するなら、この変更を伝播するために `update_dist(x, y, z)` が呼び出されます。

---

## 7. 出力

* **`print(*LANS)`**: タイプ3のクエリから収集されたすべての `ANS` 値をスペースで区切って出力します。

---

## 重要な概念と考慮事項

* **ワーシャル・フロイド法**: 全ペアの最短パスを見つけるために使用されます。その時間計算量は $O(V^3)$ で、ここで $V$ は頂点数です。この場合、$V = N+1$ です。
* **動的な更新**: `update_dist` 関数は、辺の重みの更新を処理します。これは単一の辺の更新のように見えますが、実際には新しい短いパスを他のすべてのノードに伝播させ、その辺のみのワーシャル・フロイドの「限定的な」再実行を行います。これにより、少数の辺しか変更されない場合、更新ごとにワーシャル・フロイドを一から実行するよりも効率的になります。
* **仮想ノード**: 仮想ノード `N` は、空路をモデル化するための巧妙な方法で、ワーシャル・フロイドアルゴリズムがそれらを自然に組み込むことを可能にします。2つの空路都市 $A$ と $B$ の間の移動は $D[A][N] + D[N][B] = T + T = 2T$ のコストがかかります。
* **コストの2倍化 (`c *= 2`, `z *= 2`)**: これは非常に重要な詳細です。もし問題が、各距離が2回カウントされる（例: 往復の場合）最短距離の合計を求めている場合、または中間計算で分数を避けて整数演算が有利な場合、コストを2倍にすることは理にかなっています。元の問題のさらなる文脈がなければ、その正確な目的は明確ではありませんが、これは意図的な設計上の選択です。これは、最終的な `ANS` が「2倍にされた」距離の合計を表すか、元のコストが半整数であった可能性があることを示唆しています。
* **`i < j < N` の `D[i][j]` の合計**: `ANS` は、元の `N` 個の都市間の最短パスに特に焦点を当てており、合計自体から仮想航空ハブ `N` を含むパスを除外し、二重カウントを避けています（`D[i][j]` と `D[j][i]` は同じであるため）。
* **効率**: `update_dist` は $O(V^2)$ ですが、各クエリでそれを実行すると、クエリは依然としてコストがかかる可能性があります。`Q` が大きく `N` も大きい場合、特定の要件によっては全体的な複雑さが問題になる可能性があります。

##################################################################
[hobit]
import sys
input = sys.stdin.readline
INF = 10**18
N, M = map(int, input().split())
G = [[INF]*(N+1) for i in range(N+1)]  # v=0: sky
for i in range(N+1):
    G[i][i] = 0
for _ in range(M):
    a, b, c = map(int, input().split())
    G[a][b] = G[b][a] = min(G[a][b], c*2)  # a<->b, cost=c*2
K, T = map(int, input().split())
for i in map(int, input().split()):  # D
    G[0][i] = G[i][0] = T  # i<->sky, cost=T


def update(k):
    for i in range(N+1):
        if G[k][i] < INF:
            for j in range(i):  # 対角線上について対象である前提で
                G[j][i] = G[i][j] = min(G[i][j], G[i][k] + G[k][j])


for k in range(N+1):  # floyd_warshall
    update(k)

for _ in range(int(input())):  # Q
    ty, *op = map(int, input().split())
    if ty == 1:  # (x<y), x<->y の道を作る. x,y 間を time=t で移動可能
        x, y, t = op
        G[x][y] = G[y][x] = min(G[x][y], t*2)  # x<->y, cost=t*2
        update(x)
        update(y)

    elif ty == 2:  # x の街に空港を作る. 他の空港のある街へ time=T で移動可能
        x = op[0]
        G[0][x] = G[x][0] = T  # x<->sky, cost=T
        update(0)
        update(x)

    else:  # if ty == 3:  # ΣΣf(x,y) を出力
        tot = 0
        for i in range(1, N+1):
            for j in range(1, i):
                tot += G[i][j] if G[i][j] != INF else 0
        print(tot)

##################################################################
[cgpt AC]

---

## 🔷 全体の目的

* 複数の町と道、空港からなるネットワークにおいて、

  * 全ての町の **最短距離の合計** を高速に求める。
  * 空港の追加や道路の追加といったクエリに対して、
    **最短距離を動的に更新**しつつ、合計距離を管理する。

---

## 🔸 手順の流れ（ステップごとに）

### ① 入力の受け取りと初期化

1. **町の数と道の数を受け取る**
2. **全ての町ペア間の距離行列（2次元配列）を作成**

   * 初期値は「無限大」
   * 自分自身への距離は 0
3. **各道路を読み取り、距離行列に反映**

   * 同じ道路が複数ある場合は、最小の距離のみ保持
   * 距離は内部的に 2 倍にして保持（整数処理のため）

---

### ② 空港情報の反映

4. **空港のある町のリストを受け取る**
5. **「ダミー空港ノード」を導入**

   * 各空港のある町とこのノードの間に、コスト `T` で双方向接続
   * 空港を通じた町間移動を、ダミーノード経由として表現

---

### ③ 初期の最短距離計算

6. **ワーシャル・フロイド法で全町間の最短距離を計算**

   * 空港を含めた最短距離も自動的に反映される

---

### ④ 最短距離合計の初期計算

7. **すべての町のペアについて、最短距離の合計を計算**

   * 重複しないよう、`i < j` のペアのみ合計に加算
   * この合計を `ANS` 変数に保持

---

### ⑤ クエリ処理（Q回）

8. クエリは次の3種類のいずれか：

#### 🔹 クエリタイプ 1: 道路の追加

* 指定された2つの町間に新しい道を追加
* 距離が短くなる町のペアがあれば、最短距離と合計を更新

#### 🔹 クエリタイプ 2: 空港の追加

* ある町に新たに空港を追加
* ダミーノードと接続し、空港経由で短くなる町の距離があれば更新

#### 🔹 クエリタイプ 3: 距離合計の出力

* 現在の全町ペアの最短距離合計をそのまま出力（保存用リストに追加）

---

### ⑥ 出力

9. 最後に、**タイプ3クエリで記録した距離合計を順に出力**

---

## 🧠 工夫された点

| 工夫     | 説明                                |
| ------ | --------------------------------- |
| 距離2倍   | 小数を使わず整数で処理するため。出力時に戻す必要なし（重複回避済） |
| ダミーノード | 空港を1ノードで一元管理でき、空港間接続の最短距離が簡潔に表現可能 |
| 部分的再計算 | 毎回全体を再計算せず、変更があるところだけ更新して高速化      |

---

## ✅ このコードが得意な問題タイプ

* 頻繁にグラフが更新される（道路追加・空港追加）
* 各更新後に**全体の距離合計を知りたい**
* 小規模〜中規模のグラフ（最大約100ノード程度）

---

##################################################################
[cgpt AC]
import sys
input = sys.stdin.readline

INF = 1 << 60

N, M = map(int, input().split())
D = [[INF] * (N + 1) for _ in range(N + 1)]

for i in range(N + 1):
    D[i][i] = 0

for _ in range(M):
    a, b, c = map(int, input().split())
    a -= 1
    b -= 1
    c *= 2
    D[a][b] = D[b][a] = min(D[a][b], c)

K, T = map(int, input().split())
Air = list(map(lambda x: int(x) - 1, input().split()))

for a in Air:
    D[a][N] = D[N][a] = T

# ワーシャル・フロイド
for k in range(N + 1):
    for i in range(N + 1):
        for j in range(N + 1):
            D[i][j] = min(D[i][j], D[i][k] + D[k][j])

# 距離合計（i<jのみ）
ANS = sum(D[i][j] for i in range(N) for j in range(i + 1, N) if D[i][j] < INF)

def update_dist(x, y, new_dist):
    global ANS
    for i in range(N + 1):
        for j in range(i + 1, N + 1):
            d1 = D[i][x] + new_dist + D[y][j]
            d2 = D[i][y] + new_dist + D[x][j]
            d = min(d1, d2)
            if d < D[i][j]:
                if i < N and j < N:
                    if D[i][j] >= INF:
                        ANS += d
                    else:
                        ANS -= D[i][j] - d
                D[i][j] = D[j][i] = d

Q = int(input())
LANS = []

for _ in range(Q):
    L = list(map(int, input().split()))
    t = L[0]
    if t == 3:
        LANS.append(ANS)
    elif t == 2:
        x = L[1] - 1
        D[x][N] = D[N][x] = T
        update_dist(x, N, T)
    elif t == 1:
        x, y, z = L[1] - 1, L[2] - 1, L[3] * 2
        if D[x][y] > z:
            update_dist(x, y, z)

# 出力（合計距離は内部で1回のみ数えたので /2 不要）
print(*LANS)

##################################################################
[titia]
import sys
input = sys.stdin.readline

N,M=map(int,input().split())

D=[[1<<60]*(N+1) for i in range(N+1)]

for i in range(N+1):
    D[i][i]=0

for i in range(M):
    a,b,c=map(int,input().split())
    a-=1
    b-=1
    c*=2
    D[a][b]=min(D[a][b],c)
    D[b][a]=min(D[b][a],c)

K,T=map(int,input().split())
Air=list(map(int,input().split()))

for air in Air:
    D[air-1][N]=T
    D[N][air-1]=T

for k in range(N+1): # k個までの町を使ってのDisが知れているときに
    for i in range(N+1): # 町iと
        for j in range(N+1): # 町jとの最短距離は、
            length=D[i][k]+D[j][k]
            if D[i][j]>length:
                D[i][j]=D[j][i]=length

ANS=0
for i in range(N):
    for j in range(N):
        if D[i][j]<(1<<60):
            ANS+=D[i][j]

Q=int(input())
LANS=[]

for tests in range(Q):
    L=list(map(int,input().split()))
    #print(L,D)

    if L[0]==3:
        LANS.append(ANS//2)
    elif L[0]==2:
        x=L[1]-1
        D[x][N]=T
        D[N][x]=T

        for i in range(N+1):
            for j in range(i+1,N+1):
                length=min(D[i][x]+T+D[j][N],D[i][N]+T+D[j][x])

                if length<D[i][j]:
                    if i<N and j<N:
                        if D[i][j]>=(1<<60):
                            ANS+=length*2
                        else:
                            ANS-=(D[i][j]-length)*2
                    D[i][j]=length
                    D[j][i]=length
    elif L[0]==1:
        #print("!!",ANS)
        x,y,z=L[1],L[2],L[3]
        x-=1
        y-=1
        z*=2

        if D[x][y]>z:
            for i in range(N+1):
                for j in range(i+1,N+1):
                    length=min(D[i][x]+z+D[j][y],D[i][y]+z+D[j][x])

                    if length<D[i][j]:
                    
                        if i<N and j<N:
                            if D[i][j]>=(1<<60):
                                ANS+=length*2
                            else:
                                ANS-=(D[i][j]-length)*2

                        #print(D[i][j],length,ANS)
                        D[i][j]=length
                        D[j][i]=length

print(*LANS)

##################################################################
