##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

##################################################################
[cgpt AC]

---

## 🔷 全体の目的

* 複数の町と道、空港からなるネットワークにおいて、

  * 全ての町の **最短距離の合計** を高速に求める。
  * 空港の追加や道路の追加といったクエリに対して、
    **最短距離を動的に更新**しつつ、合計距離を管理する。

---

## 🔸 手順の流れ（ステップごとに）

### ① 入力の受け取りと初期化

1. **町の数と道の数を受け取る**
2. **全ての町ペア間の距離行列（2次元配列）を作成**

   * 初期値は「無限大」
   * 自分自身への距離は 0
3. **各道路を読み取り、距離行列に反映**

   * 同じ道路が複数ある場合は、最小の距離のみ保持
   * 距離は内部的に 2 倍にして保持（整数処理のため）

---

### ② 空港情報の反映

4. **空港のある町のリストを受け取る**
5. **「ダミー空港ノード」を導入**

   * 各空港のある町とこのノードの間に、コスト `T` で双方向接続
   * 空港を通じた町間移動を、ダミーノード経由として表現

---

### ③ 初期の最短距離計算

6. **ワーシャル・フロイド法で全町間の最短距離を計算**

   * 空港を含めた最短距離も自動的に反映される

---

### ④ 最短距離合計の初期計算

7. **すべての町のペアについて、最短距離の合計を計算**

   * 重複しないよう、`i < j` のペアのみ合計に加算
   * この合計を `ANS` 変数に保持

---

### ⑤ クエリ処理（Q回）

8. クエリは次の3種類のいずれか：

#### 🔹 クエリタイプ 1: 道路の追加

* 指定された2つの町間に新しい道を追加
* 距離が短くなる町のペアがあれば、最短距離と合計を更新

#### 🔹 クエリタイプ 2: 空港の追加

* ある町に新たに空港を追加
* ダミーノードと接続し、空港経由で短くなる町の距離があれば更新

#### 🔹 クエリタイプ 3: 距離合計の出力

* 現在の全町ペアの最短距離合計をそのまま出力（保存用リストに追加）

---

### ⑥ 出力

9. 最後に、**タイプ3クエリで記録した距離合計を順に出力**

---

## 🧠 工夫された点

| 工夫     | 説明                                |
| ------ | --------------------------------- |
| 距離2倍   | 小数を使わず整数で処理するため。出力時に戻す必要なし（重複回避済） |
| ダミーノード | 空港を1ノードで一元管理でき、空港間接続の最短距離が簡潔に表現可能 |
| 部分的再計算 | 毎回全体を再計算せず、変更があるところだけ更新して高速化      |

---

## ✅ このコードが得意な問題タイプ

* 頻繁にグラフが更新される（道路追加・空港追加）
* 各更新後に**全体の距離合計を知りたい**
* 小規模〜中規模のグラフ（最大約100ノード程度）

---

##################################################################
[cgpt AC]
import sys
input = sys.stdin.readline

INF = 1 << 60

N, M = map(int, input().split())
D = [[INF] * (N + 1) for _ in range(N + 1)]

for i in range(N + 1):
    D[i][i] = 0

for _ in range(M):
    a, b, c = map(int, input().split())
    a -= 1
    b -= 1
    c *= 2
    D[a][b] = D[b][a] = min(D[a][b], c)

K, T = map(int, input().split())
Air = list(map(lambda x: int(x) - 1, input().split()))

for a in Air:
    D[a][N] = D[N][a] = T

# ワーシャル・フロイド
for k in range(N + 1):
    for i in range(N + 1):
        for j in range(N + 1):
            D[i][j] = min(D[i][j], D[i][k] + D[k][j])

# 距離合計（i<jのみ）
ANS = sum(D[i][j] for i in range(N) for j in range(i + 1, N) if D[i][j] < INF)

def update_dist(x, y, new_dist):
    global ANS
    for i in range(N + 1):
        for j in range(i + 1, N + 1):
            d1 = D[i][x] + new_dist + D[y][j]
            d2 = D[i][y] + new_dist + D[x][j]
            d = min(d1, d2)
            if d < D[i][j]:
                if i < N and j < N:
                    if D[i][j] >= INF:
                        ANS += d
                    else:
                        ANS -= D[i][j] - d
                D[i][j] = D[j][i] = d

Q = int(input())
LANS = []

for _ in range(Q):
    L = list(map(int, input().split()))
    t = L[0]
    if t == 3:
        LANS.append(ANS)
    elif t == 2:
        x = L[1] - 1
        D[x][N] = D[N][x] = T
        update_dist(x, N, T)
    elif t == 1:
        x, y, z = L[1] - 1, L[2] - 1, L[3] * 2
        if D[x][y] > z:
            update_dist(x, y, z)

# 出力（合計距離は内部で1回のみ数えたので /2 不要）
print(*LANS)

##################################################################
[titia]
import sys
input = sys.stdin.readline

N,M=map(int,input().split())

D=[[1<<60]*(N+1) for i in range(N+1)]

for i in range(N+1):
    D[i][i]=0

for i in range(M):
    a,b,c=map(int,input().split())
    a-=1
    b-=1
    c*=2
    D[a][b]=min(D[a][b],c)
    D[b][a]=min(D[b][a],c)

K,T=map(int,input().split())
Air=list(map(int,input().split()))

for air in Air:
    D[air-1][N]=T
    D[N][air-1]=T

for k in range(N+1): # k個までの町を使ってのDisが知れているときに
    for i in range(N+1): # 町iと
        for j in range(N+1): # 町jとの最短距離は、
            length=D[i][k]+D[j][k]
            if D[i][j]>length:
                D[i][j]=D[j][i]=length

ANS=0
for i in range(N):
    for j in range(N):
        if D[i][j]<(1<<60):
            ANS+=D[i][j]

Q=int(input())
LANS=[]

for tests in range(Q):
    L=list(map(int,input().split()))
    #print(L,D)

    if L[0]==3:
        LANS.append(ANS//2)
    elif L[0]==2:
        x=L[1]-1
        D[x][N]=T
        D[N][x]=T

        for i in range(N+1):
            for j in range(i+1,N+1):
                length=min(D[i][x]+T+D[j][N],D[i][N]+T+D[j][x])

                if length<D[i][j]:
                    if i<N and j<N:
                        if D[i][j]>=(1<<60):
                            ANS+=length*2
                        else:
                            ANS-=(D[i][j]-length)*2
                    D[i][j]=length
                    D[j][i]=length
    elif L[0]==1:
        #print("!!",ANS)
        x,y,z=L[1],L[2],L[3]
        x-=1
        y-=1
        z*=2

        if D[x][y]>z:
            for i in range(N+1):
                for j in range(i+1,N+1):
                    length=min(D[i][x]+z+D[j][y],D[i][y]+z+D[j][x])

                    if length<D[i][j]:
                    
                        if i<N and j<N:
                            if D[i][j]>=(1<<60):
                                ANS+=length*2
                            else:
                                ANS-=(D[i][j]-length)*2

                        #print(D[i][j],length,ANS)
                        D[i][j]=length
                        D[j][i]=length

print(*LANS)

##################################################################
