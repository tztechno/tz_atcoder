##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

##################################################################

##################################################################
[myai TLE]
def solve_ant_crossing_with_time(n, t, x_coords, directions):
    count = 0
    for i in range(n):
        for j in range(i + 1, n):
            xi, xj = x_coords[i], x_coords[j]
            di, dj = int(directions[i]), int(directions[j])
            crossing_time = None
            if xi < xj and di == 1 and dj == 0:
                crossing_time = (xj - xi) / 2.0
            elif xi > xj and di == 0 and dj == 1:
                crossing_time = (xi - xj) / 2.0
            if crossing_time is not None and 0 <= crossing_time <= t + 0.1:
                count += 1
    return count

import sys

line1 = sys.stdin.readline().strip().split()
n = int(line1[0])
t = int(line1[1])

s = sys.stdin.readline().strip()
x_coords = list(map(int, sys.stdin.readline().strip().split()))

result = solve_ant_crossing_with_time(n, t, x_coords, s)
print(result)
##################################################################
