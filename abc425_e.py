###############################################
問題文
正整数Nおよび長さNの正整数列C=(C1​,C2​,…,CN​)が与えられます。
次の条件をすべて満たす正整数列の個数を与えられた正整数Mで割った余りを求めてください。
数列の要素はすべて1以上N以下である。
各i=1,2,…,Nに対し、iは数列にちょうどCi​個含まれる。
T個のテストケースが与えられるので、それぞれについて答えを求めてください。
ただし、MはT個すべてのテストケースにおいて共通です。
###############################################
入力例 1
3 1000000000      #T,M
2                 #N1
2 2               #C
5
1 1 1 1 1
6
1 2 3 4 5 6
出力例 1
6
120
230379200
###############################################
[titia AC]

import sys
input = sys.stdin.readline

T,mod=map(int,input().split())

N=5050

Combi=[[] for i in range(N+1)]
Combi[0]=[1,0]

for i in range(1,N+1):
    Combi[i].append(1)
    for j in range(i):
        Combi[i].append((Combi[i-1][j]+Combi[i-1][j+1])%mod)
    Combi[i].append(0)

for tests in range(T):
    N=int(input())
    A=list(map(int,input().split()))

    SUM=sum(A)

    ANS=1

    for i in range(N):
        ANS=ANS*Combi[SUM][SUM-A[i]]%mod
        SUM-=A[i]

    print(ANS)

###############################################
[cgpt説明]

ポイントは「**多重集合の全順列**を段階的に数える」ことにあります。

---

## 問題を整理すると

* 長さ (N) の整数列 (C=(C_1,\dots,C_N)) が与えられる。
* 求める列 (X=(x_1,\dots,x_{\sum C_i})) は

  * すべての要素が (1) 以上 (N) 以下
  * かつ「整数 (i) がちょうど (C_i) 個含まれる」という条件を満たす

つまり、**多重集合**
[
{1^{C_1},2^{C_2},\dots,N^{C_N}}
]
を並べ替える場合の数を (M) で割った余りを求める問題です。

---

## 全体の公式

もし全部まとめて考えるなら
[
\frac{\bigl(\sum_i C_i\bigr)!}{\prod_i C_i!}
]
が多重順列の総数です。
ただし、問題では (M) は任意の正整数なので、(M) が素数とは限らず、普通に逆元を使った割り算ができません。
そのため「段階的に**二項係数**で積み上げる」方法を取っています。

---

## コードの考え方

1. **パスカルの三角形を mod (M) で構築する**

   ```python
   Combi[i][j] = (iCj mod M)
   ```

   を全部前計算しています。

2. **多重順列を順に作る**

   合計個数 `SUM = C_1 + ... + C_N` からスタートし、
   「残っている玉の中から (C_i) 個を取り出して順列に挿入する」イメージで
   [
   \binom{\text{残りの玉の総数}}{C_i}
   ]
   を掛けていきます。

   コードでは

   ```python
   for i in range(N):
       ANS = ANS * Combi[SUM][SUM - A[i]] % mod
       SUM -= A[i]
   ```

   となっていて、`SUM - A[i]` は「残りから取り除く個数」なので
   [
   \binom{\text{残っている個数}}{\text{選ぶ個数}}
   ]
   に相当します（`Combi[n][k]` は (nCk)）。

   最終的に全部掛け合わせた結果が多重順列の総数 mod (M) です。

3. **各テストケースで計算**
   先に Combi を大きなサイズで作っておけば、
   各テストケースは上記のループを回すだけになります。

---

## 流れを式で書くと

* `SUM = total = C_1+...+C_N`
* 初期値 (ans=1)
* 各 (i=1)〜(N) について
  [
  ans \leftarrow ans \cdot \binom{\text{SUM}}{C_i} \pmod{M},\quad
  \text{SUM}\leftarrow\text{SUM}-C_i
  ]

これで
[
ans = \frac{\bigl(\sum_i C_i\bigr)!}{\prod_i C_i!}\pmod{M}
]
が得られます。

---

## サンプル確認

* (N=2,C=(2,2))
  合計4個、1が2個、2が2個
  (\frac{4!}{2!2!}=6) → 出力6

* (N=5,C=(1,1,1,1,1))
  合計5個、全部異なる
  (\frac{5!}{1!1!1!1!1!}=120) → 出力120

* (N=6,C=(1,2,3,4,5,6))
  合計21個
  (\frac{21!}{1!2!3!4!5!6!}\bmod 10^9) → 出力230379200

すべて一致しています。

---

## まとめ

* 実質的には多重順列の総数を求める問題
* (M) が素数とは限らないため、階乗の逆元ではなく二項係数をパスカルの三角形で前計算
* 残りの玉から順に選ぶ形で掛け合わせていく

###############################################
[gemini 説明]

### 問題の分析

まず、問題が何を求めているかを数学的に理解しましょう。

  - 長さ$N$の正整数列 $C = (C_1, C_2, \ldots, C_N)$ が与えられます。
  - 私たちは、数字の `1` を $C_1$ 個、数字の `2` を $C_2$ 個、...、数字の `N` を $C_N$ 個、すべてを使って新しい数列を作ります。
  - この新しい数列の総長（要素の総数）は、$S = C_1 + C_2 + \ldots + C_N$ となります。
  - 問題は、この $S$ 個の要素（中には同じ数字が複数含まれる）を並び替えて作ることができる、異なる数列の総数を求めることです。

これは数学における「重複を含む順列」の問題です。その総数は**多項係数**を用いて計算できます。

$$\frac{S!}{C_1! \cdot C_2! \cdot \ldots \cdot C_N!}$$

しかし、この式を直接計算するのは大変です。
なぜなら、階乗（`!`）は非常に大きな数になり、さらにMOD（余り）を計算する際には分数の割り算（逆元）が必要になるため、実装が複雑になります。

### コードの解法アプローチ

このコードは、多項係数を直接計算する代わりに、それを**二項係数（コンビネーション）の積**に分解して計算しています。

多項係数の公式は、以下のように二項係数の積で表現できます。

$$\binom{S}{C_1} \times \binom{S-C_1}{C_2} \times \binom{S-C_1-C_2}{C_3} \times \ldots \times \binom{C_N}{C_N}$$

なぜこの式が成り立つのか見てみましょう。
$\binom{n}{k}$ は「n個の中からk個を選ぶ組み合わせの数」で、$\frac{n!}{k!(n-k)!}$ と計算されます。

1.  まず、合計 $S$ 個の空きスロットから、数字 `1` を置くための $C_1$ 個の場所を選びます。その選び方は $\binom{S}{C_1}$ 通りです。
2.  次に、残った $S-C_1$ 個の空きスロットから、数字 `2` を置くための $C_2$ 個の場所を選びます。その選び方は $\binom{S-C_1}{C_2}$ 通りです。
3.  その次に、残った $S-C_1-C_2$ 個の空きスロットから、数字 `3` を置くための $C_3$ 個の場所を選びます。その選び方は $\binom{S-C_1-C_2}{C_3}$ 通りです。
4.  これを数字 `N` まで繰り返します。

これらの選び方はすべて独立しているので、総数はこれらの積になります。
この式を展開すると、最終的に最初の多項係数の式と等しくなることがわかります。

このコードは、この二項係数の積を計算するアプローチを取っています。

### コードの解説

#### 1\. 前準備：コンビネーションテーブルの作成

```python
T,mod=map(int,input().split())

N=5050

Combi=[[] for i in range(N+1)]
Combi[0]=[1,0]

for i in range(1,N+1):
    Combi[i].append(1)
    for j in range(i):
        Combi[i].append((Combi[i-1][j]+Combi[i-1][j+1])%mod)
    Combi[i].append(0)
```

この部分では、後の計算で使う二項係数 $\binom{n}{k}$ の値をあらかじめ計算して、`Combi`という2次元リストに保存しています。
これは**動的計画法**の一種で、「パスカルの三角形」を構築しているのと同じです。

  - `N=5050`: 問題の制約から、数列の総長 `SUM` が最大でもこの程度になることを見越して設定された値です。
  - `Combi[i][j]` が $\binom{i}{j}$ の値を `mod` で割った余りを保持するようにしています。
  - 計算には、パスカルの三角形の性質である $\binom{n}{k} = \binom{n-1}{k-1} + \binom{n-1}{k}$ を利用しています。
      - `Combi[i].append((Combi[i-1][j]+Combi[i-1][j+1])%mod)` がこの計算に対応します。
  - `Combi[0]=[1,0]` や `Combi[i].append(0)` は、計算を簡単にするための番兵（sentinel）的な役割です。

この前準備により、テストケースごとにコンビネーションを計算する必要がなくなり、`Combi[n][k]` の形で高速に値を取得できます。

#### 2\. 各テストケースの計算

```python
for tests in range(T):
    N=int(input())
    A=list(map(int,input().split())) # 問題文のCに相当

    SUM=sum(A)

    ANS=1

    for i in range(N):
        # ここが核心部分
        ANS=ANS*Combi[SUM][SUM-A[i]]%mod
        SUM-=A[i]

    print(ANS)
```

この部分が、各テストケースに対して答えを計算するループです。

1.  `SUM=sum(A)`: 数列の総長 $S = \sum C_i$ を計算します。
2.  `ANS=1`: 答えを格納する変数を1で初期化します。
3.  `for i in range(N):` ループ:
      - このループが、先ほど説明した二項係数の積を順番に計算していきます。
      - **1回目のループ (i=0):**
          - `SUM` は全体の長さ $S$ です。
          - `A[0]` は $C_1$ です。
          - `Combi[SUM][SUM-A[0]]` は $\binom{S}{S-C_1}$ を計算しています。
          - 組み合わせの性質 $\binom{n}{k} = \binom{n}{n-k}$ より、これは $\binom{S}{C_1}$ と同じです。
          - `ANS` に $\binom{S}{C_1}$ を掛け合わせます。
          - `SUM-=A[i]` で、`SUM` を $S-C_1$ に更新します。
      - **2回目のループ (i=1):**
          - `SUM` は $S-C_1$ です。
          - `A[1]` は $C_2$ です。
          - `Combi[SUM][SUM-A[1]]` は $\binom{S-C_1}{S-C_1-C_2}$ を計算します。これは $\binom{S-C_1}{C_2}$ と同じです。
          - `ANS` に $\binom{S-C_1}{C_2}$ を掛け合わせます。
          - `SUM-=A[i]` で、`SUM` を $S-C_1-C_2$ に更新します。
      - これを `N` 回繰り返すことで、最終的に `ANS` には
        $$\left( \binom{S}{C_1} \times \binom{S-C_1}{C_2} \times \ldots \right) \pmod{M}$$
        が計算され、これが求める答えとなります。

### まとめ

このコードは、問題（重複を含む順列の数え上げ）を**多項係数**の問題として捉え、それを計算しやすい**二項係数の積**に分解しています。
そして、計算を高速化するために、あらかじめパスカルの三角形を用いて二項係数のテーブルを作成しておく、という非常に効率的な解法を実装しています。

###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
[my TLE]
from math import factorial
from collections import Counter

def count_permutations(seq):
    n = len(seq)
    counts = Counter(seq)  
    denom = 1
    for c in counts.values():
        denom *= factorial(c)
    return factorial(n) // denom

T,M=map(int,input().split())
for i in range(T):
  N=int(input())
  C=list(map(int,input().split()))
  D=[]
  for j in range(N):
    D+=[j+1]*C[j]
  print(count_permutations(D)%M)
###############################################
###############################################
