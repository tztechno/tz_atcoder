###############################################
###############################################
###############################################
###############################################
###############################################
###############################################

---

## 行の意味

```python
dp[j][d] = max(dp[j][d], dp[i][d] + 1)
```

### 前提

* `i < j`
* `d = idxs[j] - idxs[i]` （公差）
* `dp[i][d]` = 「idxs\[i] を終点にした、公差 d の等差数列の間の数」
* `dp[j][d]` = まだ更新されていない場合は 0（defaultdict が自動で0にする）

---

### 1. dp\[i]\[d] + 1 の意味

* `dp[i][d]` は idxs\[i] までに作れる等差数列の「間の数」
* そこに idxs\[j] を追加して延長できる → `+1`
* つまり **idxs\[j] を終点にしたときの「間の数」** は `dp[i][d] + 1` になる

---

### 2. max() を使う理由

* 同じ j, d の組に対して複数の i が考えられる

  * 例: idxs=\[0,2,4,6]

    * j=3(idx=6), d=2
    * i=0 → dp\[3]\[2] = dp\[0]\[2] +1 = 0+1=1
    * i=1 → dp\[3]\[2] = dp\[1]\[2] +1 = 1+1=2  ← これがより長い
* だから、より長い方を残すために `max()` する

---

### 3. まとめると

* `dp[j][d] = max(dp[j][d], dp[i][d] + 1)` は
  **「公差 d の等差数列を idxs\[j] で終わらせるとき、最長に更新する」**
* i を全て試すことで、j を終点とする「最大の長さ」を求められる

---

### 4. 簡単な例

`idxs = [0,2,4]` 公差 d=2 の場合：

| i | dp\[i]\[2] | dp\[i]\[2]+1 | dp\[j]\[2] 更新後 |
| - | ---------- | ------------ | -------------- |
| 0 | 0          | 1            | dp\[1]\[2] = 1 |
| 1 | 1          | 2            | dp\[2]\[2] = 2 |

* 長さ = dp\[j]\[d] + 1

  * dp\[2]\[2]+1 = 3 → `[0,2,4]`

---

💡 ポイント

* dp\[j]\[d] は「j を終点にしたときの最長列」
* dp\[i]\[d]+1 は「i を終点にした列に j を追加した場合の長さ」
* max() でより長い列を採用する

---

###############################################


---

## 2. DP の役割

「等差数列を見つける」とき、

* いま見ているインデックス $j$ を「等差数列の終点」として考えます。
* そして「公差 d の等差数列がここでどれくらい伸びているか」を記録します。
#高さごとに２次元のdpを考える
#j終点、d公差、値が始点
これを `dp[j][d]` に入れます。

---

## 3. `dp[j][d]` の意味

コメントにあるとおり：

> `dp[j][d] = 長さ（idxs[i], idxs[j]) が公差 d の等差数列`

ここで「長さ」というのは **2点間で作れる等差列の“対の数”** です。

* たとえば、

  * インデックスが `[0,2,4]` のとき、
  * (0,2) で公差 2 の列を作る → `dp[1][2] = 1`
  * (0,2,4) でさらに伸ばすと、`dp[2][2] = dp[1][2] + 1 = 2`
* 実際の長さは「対の数 + 1」なので、

  * `dp[1][2]=1` → 長さ2
  * `dp[2][2]=2` → 長さ3

---

## 4. `defaultdict(int)` を使う理由

* Python の普通の辞書だと「そのキーがまだない」とエラーになる。
* `defaultdict(int)` は、存在しないキーにアクセスしたら勝手に `0` を返してくれる。
* だから `dp[i][d] + 1` をするときに「まだその公差 d の記録がない」場合でも大丈夫。

---

## 5. 具体例

例えば高さ h=5 の位置が `idxs = [0, 2, 5]` の場合：

* j=1 (位置2), i=0 (位置0)

  * d=2 → `dp[1][2] = max(dp[1][2], dp[0][2] + 1)`
  * まだ dp\[0]\[2] は未定義 → `0`
  * だから dp\[1]\[2] = 1 になる（長さ2の等差列）。

* j=2 (位置5), i=1 (位置2)

  * d=3 → `dp[2][3] = dp[1][3] + 1 = 1`（長さ2の列）

* j=2 (位置5), i=0 (位置0)

  * d=5 → `dp[2][5] = dp[0][5] + 1 = 1`（長さ2の列）

こうして色んな公差の等差列が並行して管理される。

---

✅ まとめると

* `dp[j][d]` は「idxs\[j] を最後に使う、公差 d の等差数列の長さ（−1）」を表す
* `defaultdict(int)` にしておくと「初めて見る公差 d」も自動的に 0 から始められる

---


###############################################
[cgpt]

---

#i--jが欲しい数列の範囲

```python
    dp = [defaultdict(int) for _ in range(k)]
    # dp[j][d] = 長さ（idxs[i], idxs[j]) が公差 d の等差数列
```

* DP（動的計画法）の配列を用意。
* `dp[j][d]` は「`idxs[j]` を終点とし、公差 d の等差数列の長さ - 1（対の数）」を保持する。
* `defaultdict(int)` にしておくことで、未定義の公差 d にアクセスしても自動で 0 になる。

---

```python
    for j in range(k):
        for i in range(j):
            d = idxs[j] - idxs[i]
            dp[j][d] = max(dp[j][d], dp[i][d] + 1)
            ans = max(ans, dp[j][d] + 1)  # +1 で長さに換算
```

* 同じ高さの出現位置の組 $(i,j)$ を選んで、公差 $d = idxs[j] - idxs[i]$ を計算する。
* `dp[i][d]` が「i を終点とする長さ - 1」なので、それに `+1` して j に継続する。
* つまり「等差数列を伸ばす」処理。
* 更新した値に 1 を足して、実際の長さ（要素数）に換算し、`ans` を更新。

---

## まとめ

このプログラムは：

2. そのインデックス列の中で「公差が同じ」位置を選び続け、最長の等差数列を探す
3. すべての高さについて調べ、最長の長さを答えにする

---

###############################################
[cgpt]
from collections import defaultdict

N = int(input())
H = list(map(int, input().split()))

# 高さごとに出現位置を集める
pos = defaultdict(list)
for i, h in enumerate(H):
    pos[h].append(i)

ans = 1
for h, idxs in pos.items():
    k = len(idxs)
    if k <= ans:  # すでにこれより大きい答えがあるなら飛ばす
        continue

    dp = [defaultdict(int) for _ in range(k)]
    # dp[j][d] = 長さ（idxs[i], idxs[j]) が公差 d の等差数列

    for j in range(k):
        for i in range(j):
            d = idxs[j] - idxs[i]
            dp[j][d] = max(dp[j][d], dp[i][d] + 1)
            ans = max(ans, dp[j][d] + 1)  # +1 で長さに換算

print(ans)

###############################################

'''
N棟のビルが等間隔に一列に並んでいます。
手前からi番目のビルの高さはHiです。
あなたは次の条件をともに満たすようにいくつかのビルを選んで電飾で飾ろうとしています。
* 選んだビルたちは高さが等しい
* 選んだビルたちは等間隔に並んでいる
最大でいくつのビルを選ぶことができますか？　
'''
N=int(input())
H=list(map(int,input().split()))
from collections import defaultdict,deque,Counter
cnt = defaultdict(list)
S=set(H)
for i,h in enumerate(H):
  cnt[h].append(i)
for s in S:
  idx=cnt[s]
  count=len(idx)
  #idxのリストの中で等差の最大長を探す
  #あり得る差は1--count
  #idxのリストのiが始点、jが終点、しかし、jumpあり得る
  #DPの使い方がわからない
  #限界、ここまで

###############################################
[deepseek]
def main():
    import sys
    from collections import defaultdict
    input = sys.stdin.read
    data = input().split()
    n = int(data[0])
    H = list(map(int, data[1:1+n]))
    
    cnt = defaultdict(list)
    for i, h in enumerate(H):
        cnt[h].append(i)
    
    ans = 1
    for key, indices in cnt.items():
        m = len(indices)
        if m <= 2:
            # 2以下ならその数が最大
            if m > ans:
                ans = m
            continue
        
        # 動的計画法: dp[i]はi番目で終わる最長等差数列の長さ（ただし公差は固定しないとできないので、公差ごとにやる？）
        # 代わりに、可能な公差をすべて試すのは非効率なので、別の方法をとる。
        # 実際には、隣接するインデックスの差の種類は多くないので、すべての公差を試す。
        # ただし、公差dは、隣接する要素の差の約数などに限られるが、ここではすべての可能なdを試す代わりに、隣接する差の値を公差として使う。
        # しかし、それでは不十分なので、すべての可能な公差（つまり、indices[j]-indices[i] for i<j）を試すのはO(m^2)でmが大きいと厳しい。
        # そこで、まずは隣接する差の値の約数を公差として考えるなどするが、簡単のため、mが大きい場合はスキップする？実際mが大きい場合、最大長は小さくなる可能性が高い。
        # あるいは、次のようにする：最大長を求めるには、小さな公差から試すのが良い。例えば公差1から。
        # しかし、問題では最大で100000なので、mが100以上の場合には工夫が必要。
        
        # ここでは、mが100より大きい場合は、隣接する差の中で最も頻度の高い差の約数を公差として試すなど、ヒューリスティックな方法をとることもできるが、
        # まずはmが小さい場合のみを考え、mが大きい場合はとりあえず飛ばす？実際、同じ高さのビルが100以上あることは稀なので、すべてのグループのmが100以下なら問題ない。
        
        # この問題のテストケースでは、同じ高さのビルが多くないことを仮定して、すべての可能な公差を試す。
        # ただし、mが100を超える場合は、時間を節約するために、隣接する差の値の集合だけを公差として試す。
        # 隣接する差の値の集合のサイズはm-1なので、これでもまだ多いが、実際には重複があるのでそれほど多くない。
        diffs = set()
        for i in range(1, m):
            diffs.add(indices[i] - indices[i-1])
        
        # さらに、これらの差の約数も公差としてあり得るが、最大長を求めるには、約数まで試す必要がある？
        # 例えば、インデックスが[0,4,6,8,12]で公差2の等差数列[0,4,8,12]は？しかし、4-0=4, 6-4=2, 8-6=2, 12-8=4なので、隣接差は4,2,2,4。
        # 公差2の数列を見つけるには、隣接差の2は使うが、約数まで考える必要はない（公差2そのものがある）。
        # したがって、diffsに含まれる値と、その約数？は必要ない。なぜなら、公差dの数列をチェックするには、dそのものが差の集合にない場合でも、例えばd=2が公差なら、それは隣接差の2と等しいのでdiffsに含まれる。
        # なので、diffsの要素だけで十分？しかし、例えばインデックス[0,3,6,9]なら隣接差は3,3,3なのでdiffs={3}。公差3は含まれる。
        # しかし、インデックス[0,2,4,6]なら隣接差は2,2,2でdiffs={2}。公差2は含まれる。
        # では、インデックス[0,4,6,8,12]で公差2の数列[0,4,8,12]を考えたい場合、隣接差は4,2,2,4なので、diffs={2,4}。公差2は含まれる。
        # したがって、diffsの要素を公差として試せば、すべての可能な公差をカバーできる。
        
        # しかし、実はこれでは不十分な場合がある。例えば、インデックス[0,2,6,8]で公差2の数列[0,2,4,6,8]のうち[0,2,6,8]は？しかし、これは等差数列ではない（2-0=2,6-2=4,8-6=2）。
        # なので、このグループでは公差2の数列は[0,2]と[6,8]だけ。
        # では、インデックス[0,3,6,9,12]で公差3の数列は隣接差が3,3,3,3なのでdiffs={3}でカバーできる。
        # 以上より、diffsの要素を公差として試せばよい。
        
        best_for_key = 1
        for d in diffs:
            # 公差dの等差数列の最大長を求める
            # DPを使う: dp[i] = i番目の要素まで使ったときの最長の等差数列の長さ
            # ただし、直前の要素との差がdであるような数列を追う。
            dp = {}
            for idx in indices:
                prev = idx - d
                if prev in dp:
                    dp[idx] = dp[prev] + 1
                else:
                    dp[idx] = 1
                if dp[idx] > best_for_key:
                    best_for_key = dp[idx]
        if best_for_key > ans:
            ans = best_for_key
            
    print(ans)

if __name__ == '__main__':
    main()

###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
