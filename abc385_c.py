###############################################
###############################################
###############################################
###############################################
###############################################
###############################################

---

## 行の意味

```python
dp[j][d] = max(dp[j][d], dp[i][d] + 1)
```

### 前提

* `i < j`
* `d = idxs[j] - idxs[i]` （公差）
* `dp[i][d]` = 「idxs\[i] を終点にした、公差 d の等差数列の間の数」
* `dp[j][d]` = まだ更新されていない場合は 0（defaultdict が自動で0にする）

---

### 1. dp\[i]\[d] + 1 の意味

* `dp[i][d]` は idxs\[i] までに作れる等差数列の「間の数」
* そこに idxs\[j] を追加して延長できる → `+1`
* つまり **idxs\[j] を終点にしたときの「間の数」** は `dp[i][d] + 1` になる

---

### 2. max() を使う理由

* 同じ j, d の組に対して複数の i が考えられる

  * 例: idxs=\[0,2,4,6]

    * j=3(idx=6), d=2
    * i=0 → dp\[3]\[2] = dp\[0]\[2] +1 = 0+1=1
    * i=1 → dp\[3]\[2] = dp\[1]\[2] +1 = 1+1=2  ← これがより長い
* だから、より長い方を残すために `max()` する

---

### 3. まとめると

* `dp[j][d] = max(dp[j][d], dp[i][d] + 1)` は
  **「公差 d の等差数列を idxs\[j] で終わらせるとき、最長に更新する」**
* i を全て試すことで、j を終点とする「最大の長さ」を求められる

---

### 4. 簡単な例

`idxs = [0,2,4]` 公差 d=2 の場合：

| i | dp\[i]\[2] | dp\[i]\[2]+1 | dp\[j]\[2] 更新後 |
| - | ---------- | ------------ | -------------- |
| 0 | 0          | 1            | dp\[1]\[2] = 1 |
| 1 | 1          | 2            | dp\[2]\[2] = 2 |

* 長さ = dp\[j]\[d] + 1

  * dp\[2]\[2]+1 = 3 → `[0,2,4]`

---

💡 ポイント

* dp\[j]\[d] は「j を終点にしたときの最長列」
* dp\[i]\[d]+1 は「i を終点にした列に j を追加した場合の長さ」
* max() でより長い列を採用する

---

###############################################


---

## 2. DP の役割

「等差数列を見つける」とき、

* いま見ているインデックス $j$ を「等差数列の終点」として考えます。
* そして「公差 d の等差数列がここでどれくらい伸びているか」を記録します。
#高さごとに２次元のdpを考える
#j終点、d公差、値が始点
これを `dp[j][d]` に入れます。

---

## 3. `dp[j][d]` の意味

コメントにあるとおり：

> `dp[j][d] = 長さ（idxs[i], idxs[j]) が公差 d の等差数列`

ここで「長さ」というのは **2点間で作れる等差列の“対の数”** です。

* たとえば、

  * インデックスが `[0,2,4]` のとき、
  * (0,2) で公差 2 の列を作る → `dp[1][2] = 1`
  * (0,2,4) でさらに伸ばすと、`dp[2][2] = dp[1][2] + 1 = 2`
* 実際の長さは「対の数 + 1」なので、

  * `dp[1][2]=1` → 長さ2
  * `dp[2][2]=2` → 長さ3

---

## 4. `defaultdict(int)` を使う理由

* Python の普通の辞書だと「そのキーがまだない」とエラーになる。
* `defaultdict(int)` は、存在しないキーにアクセスしたら勝手に `0` を返してくれる。
* だから `dp[i][d] + 1` をするときに「まだその公差 d の記録がない」場合でも大丈夫。

---

## 5. 具体例

例えば高さ h=5 の位置が `idxs = [0, 2, 5]` の場合：

* j=1 (位置2), i=0 (位置0)

  * d=2 → `dp[1][2] = max(dp[1][2], dp[0][2] + 1)`
  * まだ dp\[0]\[2] は未定義 → `0`
  * だから dp\[1]\[2] = 1 になる（長さ2の等差列）。

* j=2 (位置5), i=1 (位置2)

  * d=3 → `dp[2][3] = dp[1][3] + 1 = 1`（長さ2の列）

* j=2 (位置5), i=0 (位置0)

  * d=5 → `dp[2][5] = dp[0][5] + 1 = 1`（長さ2の列）

こうして色んな公差の等差列が並行して管理される。

---

✅ まとめると

* `dp[j][d]` は「idxs\[j] を最後に使う、公差 d の等差数列の長さ（−1）」を表す
* `defaultdict(int)` にしておくと「初めて見る公差 d」も自動的に 0 から始められる

---


###############################################
[cgpt]

---

#i--jが欲しい数列の範囲

```python
    dp = [defaultdict(int) for _ in range(k)]
    # dp[j][d] = 長さ（idxs[i], idxs[j]) が公差 d の等差数列
```

* DP（動的計画法）の配列を用意。
* `dp[j][d]` は「`idxs[j]` を終点とし、公差 d の等差数列の長さ - 1（対の数）」を保持する。
* `defaultdict(int)` にしておくことで、未定義の公差 d にアクセスしても自動で 0 になる。

---

```python
    for j in range(k):
        for i in range(j):
            d = idxs[j] - idxs[i]
            dp[j][d] = max(dp[j][d], dp[i][d] + 1)
            ans = max(ans, dp[j][d] + 1)  # +1 で長さに換算
```

* 同じ高さの出現位置の組 $(i,j)$ を選んで、公差 $d = idxs[j] - idxs[i]$ を計算する。
* `dp[i][d]` が「i を終点とする長さ - 1」なので、それに `+1` して j に継続する。
* つまり「等差数列を伸ばす」処理。
* 更新した値に 1 を足して、実際の長さ（要素数）に換算し、`ans` を更新。

---

## まとめ

このプログラムは：

2. そのインデックス列の中で「公差が同じ」位置を選び続け、最長の等差数列を探す
3. すべての高さについて調べ、最長の長さを答えにする

---

###############################################
[cgpt]
from collections import defaultdict

N = int(input())
H = list(map(int, input().split()))

# 高さごとに出現位置を集める
pos = defaultdict(list)
for i, h in enumerate(H):
    pos[h].append(i)

ans = 1
for h, idxs in pos.items():
    k = len(idxs)
    if k <= ans:  # すでにこれより大きい答えがあるなら飛ばす
        continue

    dp = [defaultdict(int) for _ in range(k)]
    # dp[j][d] = 長さ（idxs[i], idxs[j]) が公差 d の等差数列

    for j in range(k):
        for i in range(j):
            d = idxs[j] - idxs[i]
            dp[j][d] = max(dp[j][d], dp[i][d] + 1)
            ans = max(ans, dp[j][d] + 1)  # +1 で長さに換算

print(ans)

###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
###############################################
